---
title: "Présentation des données"
author: "Antoine Buvat / Julien Langevin / Mickaël Walter"
date: "20/09/2019"
output:
  html_document: default
  pdf_document: default
---
## Données brutes

Dans le cadre de notre démonstrateur, nous avons fait le choix d'utiliser une base de données issue d'un site open source. Le base de données se nomme __Credit Card Fraud Detection__. Elle est disponible sur ce site <https://www.kaggle.com/mlg-ulb/creditcardfraud>.  

Cette base de données contient la liste de toute les transactions faite par carte de crédit en Septembre 2013 par des clients européens possédant une carte de crédit. De plus, elle fait la distinction entre les transactions frauduleuses et les transactions légales.  

Notre jeu de données contient __284807 observations__ ainsi que les __31 variables__ suivantes:

- __Amount__: Coût de la transaction     
- __V1 à V28__: variables qui ont été obtenues à l'aide d'une ACP et qui ont été anonymisées pour des raisons de confidentialité.      
- __Time__: seconde entre la premiere transaction et la transaction en question.    
- __Class__: prend pour modalité 1 si la transaction est frauduleuse et 0 sinon. Il s'agit de notre variable de réponse.  

On cherche à construire un modèle qui prédit la fraude ou non d'un client en fonction des autres variables par la méthode de __machine à vecteur de support__ (SVM).

## Problèmes de déséquilibre

Sur les 284807 observations, nous pouvons seulement observer __492 cas de fraude__, soit __0.172%__. En effet, la fraude correspond à un évenement rare et c'est pour cela que notre base de données est donc fortement déséquilibrée.

Cependant, il existe deux types de méthodes pour répondre a cette problèmatique: 

- La __méthode Random Under Sampling__ (RUS): cette méthode consiste à retirer une partie des observations non frauduleuses de l'échantillion d'apprentissage de manière aléatoire, afin qu'elle ne représente plus qu'une certaine proportion fixé de l'échantillon. Elle a pour avantage de limiter le temps d'exécution de l'algorithme puisqu'elle utilise beaucoup moins de ressources. En effet, notre base  de données est beaucoup plus petite par rapport à la base de données originale. En revanche, on perd de l'information. Pour éviter ce problème, il existe des méthodes d'undersampling telle que la One-Sided Selection (OSS) qui consiste à éliminer certains individus de la classe majoritaire par la méthode des voisins les plus proches.  
- La __méthode Random Over Sampling__ (ROS): cette méthode consiste à augmenter le nombre d'individus frauduleux par une duplication aléatoire, afin qu'ils représentent une certaine proportion fixé de l'échantillon d'apprentissage.Dans cette méthode, on ne perd aucune information et donc les résultats seront meilleurs. En revanche, on a un risque d'overfitting liée à la présence de multiple individus identiques.Pour éviter ce risque, on peut recourir à la méthode du __SMOTE__ (Synthetic Minority Over-sampling Technique), méthode d'oversampling qui consiste à créer des individus frauduleux à partir des individus déja existant.  

La méthode d'oversampling par SMOTE est jugé de manière général comme la plus performante.

## Nos modifications 

Mais viens notre second problème, technique cette fois: notre jeu de données requiert énormément de ressources. Notre objectif étant de construire un démonstrateur simple et ludique de la méthode de __machine à vecteur de support__ (SVM), nous avons fait le choix de modifier nos données par undersampling en utilisant __la méthode du Random Under Sampling__ (RUS). Ci-dessous vous observerez la façon dont nous avons procéder: 






